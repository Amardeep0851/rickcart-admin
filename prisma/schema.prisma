generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url = env("DATABASE_URL")
}

model User{
  id String @id @default(uuid())
  email String @unique
  emailVerified Boolean @default(false)
  hashedPassword String
  firstName String
  lastName String
  phone String?
  secondPhone String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  sessions Session[]
  otps Otp?
  accounts Account[]
  address Address[]
  @@index([email])
  @@map("users")
}

model Session {
  id String @default(uuid())
  hashedSessionToken String @unique
  userId String
  userAgent String?
  ip String?
  createdAt DateTime @default(now())
  expiresAt    DateTime

  user User @relation(fields: [userId], references: [id])
  @@index([userId])
  @@index([hashedSessionToken])  
  @@map("sessions")
  
}

model Otp {
  id String @id @default(uuid())
  userId String @unique
  otp String
  failedAttempts Int @default(0)
  hashedToken String?
  type OtpType
  expiresAt DateTime
  user User @relation(fields: [userId], references: [id])

  @@index([userId])
  @@map("otps") // keep the same table
}

enum OtpType {
  Password
  Email
}

model Account {
  id String  @id @default(uuid())
  userId String
  provider String
  providerAccountId String
  accessToken String?
  refreshToken String?
  expiresAt Int?

  user User @relation(fields: [userId], references: [id])

  @@unique([provider, providerAccountId])
  @@index([userId])
  @@map("accounts")
}
model Address {
  id String   @id @default(uuid())
  userId String
  house String
  city String
  state String
  zip String
  country String
  isDefault Boolean  @default(false)

  user User @relation(fields: [userId], references: [id])

  @@index([userId])
}
model Store {
  id     String @id @default(uuid())
  name   String
  userId String

  status Boolean @default(true)

  billboards     Billboard[]     @relation("StoreToBillboard")
  categories     Category[]      @relation("StoreToCategory")
  products       Product[]       @relation("StoreToProduct")
  productOptions ProductOption[] @relation("StoreToProductOption")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@map("stores")
}

model Billboard {
  id         String  @id @default(uuid())
  title      String
  imageUrl   String
  buttonText String?
  status     Boolean @default(true)
  link       String?
  altText    String?
  priority   Int?    @default(0)
  
  storeId    String
  store      Store      @relation("StoreToBillboard", fields: [storeId], references: [id], onDelete: Cascade)
  categories Category[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([storeId, status])
  @@map("billboards")
}

enum Icon {
  ShoppingCart
  ShoppingBag
  Package
  Boxes
  Tag
  Percent
  Gift
  BadgeDollarSign
  CreditCard
  Wallet
  User
  Users
  UserPlus
  LogIn
  LogOut
  Settings
  Heart
  Star
  Home
  Search
  Filter
  LayoutDashboard
  Grid
  List
  Bookmark
  Bell
  Truck
  Receipt
  ClipboardList
  CheckCircle
  XCircle
  MonitorSmartphone
  Printer
  Tablet
  SmartPhone
  Camera
  Bed
  Lamp
}
model Category {
  id              String   @id @default(uuid())
  name            String
  icon            Icon
  status          Boolean  @default(true)
  slug            String
  description     String?  @db.Text
  isFeatured      Boolean? @default(false)
  metaTitle       String?
  metaDescription String?  @db.Text
  imageUrl        String?
  sortOrder       Int      @default(0)

  // Hierarchy
  parentId String?
  parent   Category?  @relation("CategoryHierarchy", fields: [parentId], references: [id])
  children Category[] @relation("CategoryHierarchy")

  storeId String
  store   Store  @relation("StoreToCategory", fields: [storeId], references: [id], onDelete: Cascade)

  billboardId String?
  billboard   Billboard? @relation(fields: [billboardId], references: [id], onDelete: SetNull)

  products Product[] @relation("CategoryToProduct")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([storeId, slug])
  @@index([id, status])
  @@index([storeId, status])
  @@index([id, parentId])
  @@map("categories")
}

model Product {
  id          String  @id @default(uuid())
  userId      String
  name        String
  slug        String
  description String? @db.Text
  

  // Pricing
  price        Decimal @db.Decimal(10,2) 
  comparePrice Decimal? @db.Decimal(10, 2)
  costPrice    Decimal? @db.Decimal(10, 2)

  // Inventory
  barcode       String? @unique
  trackQuantity Boolean @default(true)
  quantity      Int     @default(0)
  lowStockAlert Int?

  // Status
  isActive   Boolean @default(true)
  isFeatured Boolean @default(false)

  // SEO
  metaTitle       String?
  metaDescription String? @db.Text
  tags       String[] // Array of tags

  // Product attributes
  weight     Decimal? @db.Decimal(8, 3) // Support weight in kg/lbs
  dimensions Json? // {length, width, height, unit}

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  storeId String
  store   Store  @relation("StoreToProduct", fields: [storeId], references: [id], onDelete: Cascade)

  categoryId String
  category   Category @relation("CategoryToProduct", fields: [categoryId], references: [id])

  images ProductImage[]

  productOptions ProductOption[] @relation("ProductToProductOption")
  @@unique([storeId, slug])
  @@index([storeId, isActive])
  @@index([categoryId])
  @@index([isFeatured])
  @@index([quantity])
  @@map("products")
}

model ProductImage {
  id        String  @id @default(uuid())
  productId String
  url       String
  altText   String?
  sortOrder Int     @default(0)

  product Product @relation(fields: [productId], references: [id], onDelete: Cascade)

  @@index([productId, sortOrder]) 
  @@map("product_images")
}

model ProductOption {
  id   String @id @default(uuid())
  name String

  storeId  String
  store    Store                @relation("StoreToProductOption", fields: [storeId], references: [id], onDelete: Cascade)
  products Product[]            @relation("ProductToProductOption")
  values   ProductOptionValue[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([storeId, name])
  @@unique([storeId, id])
  @@map("product_options")
}

model ProductOptionValue {
  id String @id @default(uuid())

  optionId String
  option   ProductOption @relation(fields: [optionId], references: [id], onDelete: Cascade)

  value String // "Large", "Red", etc.

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([optionId])
  @@map("product_option_values")
}

// // ✅ FIX: Add product variants for inventory tracking
// model ProductVariant {
//   id        String  @id @default(uuid())
//   productId String
//   sku       String? @unique

//   // Variant-specific pricing and inventory
//   price     Decimal? @db.Decimal(10,2)
//   quantity  Int      @default(0)

//   // Variant attributes (combination of options)
//   attributes Json // e.g., {"Size": "Large", "Color": "Red"}

//   isActive  Boolean @default(true)

//   product   Product @relation(fields: [productId], references: [id], onDelete: Cascade)

//   createdAt DateTime @default(now())
//   updatedAt DateTime @updatedAt

//   @@index([productId])
//   @@index([quantity])
//   @@map("product_variants")
// }

// ✅ ADD: Missing essential models for e-commerce


// model Order {
//   id         String @id @default(uuid())
//   orderNumber String @unique // Human-readable order number

//   userId String
//   user   Customer @relation(fields: [customerId], references: [id])

//   storeId    String // ✅ FIX: Orders belong to stores

//   // Order totals
//   subtotal     Decimal @db.Decimal(10,2)
//   taxAmount    Decimal @db.Decimal(10,2) @default(0)
//   shippingCost Decimal @db.Decimal(10,2) @default(0)
//   totalAmount  Decimal @db.Decimal(10,2)

//   // Status
//   status        String @default("pending") // pending, confirmed, shipped, delivered, cancelled
//   paymentStatus String @default("pending") // pending, paid, failed, refunded

//   // Addresses
//   shippingAddress Json
//   billingAddress  Json?

//   // Fulfillment
//   trackingNumber String?
//   shippedAt     DateTime?
//   deliveredAt   DateTime?

//   createdAt DateTime @default(now())
//   updatedAt DateTime @updatedAt

//   items OrderItem[]

//   @@index([customerId])
//   @@index([storeId])
//   @@index([status])
//   @@index([createdAt])
//   @@map("orders")
// }

// model OrderItem {
//   id         String  @id @default(uuid())
//   orderId    String
//   productId  String
//   variantId  String? // If product has variants

//   quantity   Int
//   price      Decimal @db.Decimal(10,2) // Price at time of order

//   order      Order   @relation(fields: [orderId], references: [id], onDelete: Cascade)

//   createdAt  DateTime @default(now())

//   @@index([orderId])
//   @@index([productId])
//   @@map("order_items")
// }
